#include <windows.h>
#include <stdio.h>
#include <iostream>
#include <string.h>

using namespace std;
int main() {
    int pid;
    scanf_s("%d", &pid);
    HANDLE Nphandle = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, FALSE, pid);
        if (Nphandle == NULL) {
            MessageBoxA(NULL, "Failed to open process", "Error", MB_OK);
            return 1;
        }
    char dllPath[100];
    DWORD f = GetFullPathNameA("Jonathan_Blaze.dll", 100, dllPath, NULL);
    printf(dllPath);
    if (f == 0) {
        MessageBoxA(NULL, "Failed to get full path", "Error", MB_OK);
        
        return 1;
    }


    LPVOID dllPathAddr = VirtualAllocEx(Nphandle, NULL, strlen(dllPath), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (dllPathAddr==NULL){
        MessageBoxA(NULL, "Failed to Virtual AllocEx", "Error", MB_OK);
    }

    WriteProcessMemory(Nphandle, dllPathAddr, dllPath, strlen(dllPath), NULL);


    LPTHREAD_START_ROUTINE LoadProcAddr = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
    if (LoadProcAddr == NULL) {
        MessageBoxA(NULL, "Failed to get LoadLibraryA address", "Error", MB_OK);
        return 1;
    }
    LPDWORD Threadid;
    HANDLE hthread = CreateRemoteThread(Nphandle, NULL, 0,LoadProcAddr , dllPathAddr, 0, Threadid);
    if (hthread == NULL) {
        MessageBoxA(NULL, "Failed to create remote thread", "Error", MB_OK);
        return 1;
    }
	CloseHandle(Nphandle);
}