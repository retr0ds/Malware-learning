// DLL_Injection.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <Windows.h>
#include <stdio.h>
#include <iostream>
#include <TlHelp32.h>
#include <string.h>


PROCESSENTRY32 Process = {
    Process.dwSize = sizeof(PROCESSENTRY32)
};


void Inject_DLL(IN int pid, IN wchar_t* DLL_Name) {

    wchar_t Dll_full_path[MAX_PATH];
    SIZE_T Number_Of_Bytes_Written;
    HANDLE hProcess;

    //Take the dll name and convert it into a full path name 
    GetFullPathNameW(DLL_Name, MAX_PATH,Dll_full_path, NULL);
    wprintf(L"\nFull Path of DLL retrieved : %ls", Dll_full_path);
    
    //Open Process to get the handle to the given pid
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (hProcess == NULL) {
        printf("\n[*] OpenProcess Failed with error : %d", GetLastError());
        exit(1);
    }


    //VirtualAllocEx used to get the pointer to the address of the allocated space on the Virtual Memory
    LPVOID Inject_Address = VirtualAllocEx(hProcess,NULL, wcslen(Dll_full_path) * sizeof(wchar_t), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (Inject_Address == NULL) {
        printf("\n[*] VirutalAllocEx Failed with error : %d", GetLastError());
        exit(1);
    }

    //WriteProcessMemory used to write the contents from Dll_full_path to Inject_Address (the allocated space from VirtualAllocEx)
    BOOL Write_Status = WriteProcessMemory(hProcess, Inject_Address, Dll_full_path, wcslen(Dll_full_path) * sizeof(wchar_t), &Number_Of_Bytes_Written);

    printf("\nLength of DLL FULL PATH : %d\n", wcslen(Dll_full_path));
    printf("\n Size of wchar_t = %d\n", sizeof(wchar_t));

    if (!Write_Status) {
        printf("\n[*] WriteProcessMemroy Failed with erro r: %d", GetLastError());
    }

    HANDLE hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "LoadLibraryW"), Inject_Address, NULL, NULL);
    if (hThread == NULL) {
        printf("[*] CreateRemoteThread Failed with error : %d", GetLastError());
        exit(1);
    }
    printf("Dont_");
}


void Process_Enum() {
    HANDLE Snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    Process32FirstW(Snapshot, &Process);

    do {
        wprintf(L"\nPROCESS NAME : %-40s PID : %d", Process.szExeFile, Process.th32ProcessID);
    } while (Process32NextW(Snapshot, &Process));
}


int main() {
	

    BOOL x = 1;
    while (x) {

        int pid;
        char choice;
        wchar_t DLL_Name[MAX_PATH];

        printf("\n\n[*][*][*] Remote DLL Injection [*][*][*]\n");
        printf("To print all process Names and PID       : [A] \n");
        printf("To inject into a process with it's PID   : [P] \n");
        printf("To Exit                                  : [X] \n");
        printf("Enter choice A/P/X: ");
        std::cin >> choice;

        if (choice == 'A')
            Process_Enum();

        else if (choice == 'P') {
            printf("\nEnter the PID : ");
            scanf_s("%d", &pid);
            printf("\nEnter the name of the DLL in same directory as this executable to inject : ");
            wscanf_s(L"%ls", DLL_Name);
            Inject_DLL(pid, DLL_Name);

        }
        else if (choice == 'X')
            x = 0;
    }
	return 0;
}