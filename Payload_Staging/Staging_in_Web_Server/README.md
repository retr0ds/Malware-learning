# About

This features hosting a payload in a webserver and retrieving it in runtime from the malware/binary, rather than storing the payload in the binary.

This reduces the chances of being detected and completely avoids static analysis and other forms of static detection methods and tools. This is highly effective when encrypted and sent over the internet. However, my implementation just features a direct unencrypted retrieval and storing, to just show how the technique works.

# Technique

The technique to retireving a shellcode is the same as that of any other resource that Windows processes use to get over the servers.

- [InternetOpenW](https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopenw) is used to Open a Handle to an Internet Session Handle using WinINet functions.
- [InternetOpenUrlW](https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopenurlw) is used to open a handle to the resource using the resource's URL
- [InternetReadFile](https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetreadfile) is next used to Read the number of bytes that we specify of the given resource 
- [InternetCloseHandle](https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetclosehandle) - Closing any open handles


These steps cover the Internet retrieval aspect of the malware. Now we, can just go about the normal routine of copying this shellcode to a new memory space, making it executable and then executing it. 

For more information on how to do this, checkout this [repo](https://github.com/retr0ds/Malware-learning/tree/main/Shellcode-Injection).

# Hosting

I had hosted this shellcode on my localhost for demonstration purposes over the python http server utility, in the same directory as the [`calc.bin`](Payload/calc.bin) 

```bash
python -m http.server 8000
```